# 语义搜索功能使用指南

## 功能概述

语义搜索模块提供基于 TF-IDF 和余弦相似度的提示词语义推荐功能，支持中英文混合文本。

## 快速开始

### 1. 初始化服务

在应用启动时初始化语义搜索服务（建议在 `App.tsx` 或 `main.tsx` 中）：

```typescript
import { SemanticSearchService } from '@/service/SemanticSearch';
import { mockPrompts } from '@/data/mockData';

// 在应用启动时初始化
useEffect(() => {
  const initSemanticSearch = async () => {
    try {
      const service = SemanticSearchService.getInstance();
      
      // 初始化服务
      await service.initialize();
      console.log('语义搜索服务已就绪');

      // 批量索引现有提示词
      const prompts = mockPrompts.map(p => ({
        id: p.id.toString(),
        text: p.description
      }));
      
      await service.indexBatch(prompts);
      console.log(`已索引 ${service.getIndexedCount()} 条提示词`);
    } catch (error) {
      console.error('语义搜索初始化失败:', error);
    }
  };

  initSemanticSearch();
}, []);
```

### 2. 在 PromptLibrary 中集成搜索

创建一个自定义 Hook 来处理语义搜索：

```typescript
// hooks/useSemanticPromptSearch.ts
import { useState, useCallback } from 'react';
import { SemanticSearchService } from '@/service/SemanticSearch';
import { usePromptListStore } from '@/stores/usePromptListStore';
import { mockPrompts } from '@/data/mockData';

export function useSemanticPromptSearch() {
  const service = SemanticSearchService.getInstance();
  const { 
    searchType, 
    setSemanticResults, 
    setIsSemanticSearching 
  } = usePromptListStore();

  const performSemanticSearch = useCallback(async (query: string) => {
    if (!query.trim() || searchType !== 'semantic') {
      setSemanticResults([]);
      return;
    }

    try {
      setIsSemanticSearching(true);
      
      const results = await service.search(query, {
        topK: 10,
        threshold: 0.1
      });

      setSemanticResults(results);
    } catch (error) {
      console.error('语义搜索失败:', error);
      setSemanticResults([]);
    } finally {
      setIsSemanticSearching(false);
    }
  }, [searchType, service, setSemanticResults, setIsSemanticSearching]);

  return { performSemanticSearch };
}
```

### 3. 在搜索组件中使用

```typescript
// features/PromptLibrary/components/PromptSearchBar.tsx
import { usePromptListStore } from '@/stores/usePromptListStore';
import { useSemanticPromptSearch } from '@/hooks/useSemanticPromptSearch';

export function PromptSearchBar() {
  const { 
    promptQuery, 
    setPromptQuery, 
    searchType, 
    setSearchType 
  } = usePromptListStore();
  
  const { performSemanticSearch } = useSemanticPromptSearch();

  const handleSearch = async (value: string) => {
    setPromptQuery(value);
    
    if (searchType === 'semantic') {
      await performSemanticSearch(value);
    }
  };

  return (
    <div className="search-container">
      {/* 搜索类型切换 */}
      <div className="search-type-toggle">
        <button 
          onClick={() => setSearchType('keyword')}
          className={searchType === 'keyword' ? 'active' : ''}
        >
          关键词搜索
        </button>
        <button 
          onClick={() => setSearchType('semantic')}
          className={searchType === 'semantic' ? 'active' : ''}
        >
          语义搜索
        </button>
      </div>

      {/* 搜索输入框 */}
      <input
        type="text"
        value={promptQuery}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder={
          searchType === 'semantic' 
            ? '输入描述，智能推荐相关提示词...' 
            : '搜索提示词...'
        }
      />
    </div>
  );
}
```

### 4. 显示搜索结果

```typescript
// features/PromptLibrary/components/PromptList.tsx
import { usePromptListStore } from '@/stores/usePromptListStore';
import { mockPrompts } from '@/data/mockData';

export function PromptList() {
  const { 
    searchType, 
    semanticResults, 
    isSemanticSearching,
    promptQuery 
  } = usePromptListStore();

  // 根据搜索类型获取提示词列表
  const getFilteredPrompts = () => {
    if (searchType === 'semantic' && semanticResults.length > 0) {
      // 语义搜索：按相似度排序
      return semanticResults.map(result => {
        const prompt = mockPrompts.find(p => p.id.toString() === result.id);
        return {
          ...prompt,
          semanticScore: result.score,
          matchedKeywords: result.matchedKeywords
        };
      });
    } else {
      // 关键词搜索：传统过滤
      return mockPrompts.filter(p => 
        p.description.toLowerCase().includes(promptQuery.toLowerCase())
      );
    }
  };

  const prompts = getFilteredPrompts();

  if (isSemanticSearching) {
    return <div>正在搜索...</div>;
  }

  return (
    <div className="prompt-list">
      {prompts.map(prompt => (
        <PromptItem 
          key={prompt.id} 
          prompt={prompt}
          // 显示语义搜索的额外信息
          semanticScore={prompt.semanticScore}
          matchedKeywords={prompt.matchedKeywords}
        />
      ))}
    </div>
  );
}
```

### 5. 增量索引（添加新提示词时）

```typescript
// 当用户创建新提示词时
const handleCreatePrompt = async (newPrompt: PromptData) => {
  // 保存到数据库...
  
  // 索引到语义搜索
  const service = SemanticSearchService.getInstance();
  await service.indexPrompt(
    newPrompt.id.toString(), 
    newPrompt.description
  );
};

// 当用户删除提示词时
const handleDeletePrompt = async (promptId: string) => {
  // 从数据库删除...
  
  // 从语义搜索索引中删除
  const service = SemanticSearchService.getInstance();
  await service.removePrompt(promptId);
};
```

## API 参考

### SemanticSearchService

#### `initialize(): Promise<void>`
初始化服务，加载分词器和已有索引。

#### `search(query: string, options?: SearchOptions): Promise<SearchResult[]>`
执行语义搜索。

**参数：**
- `query`: 搜索查询文本
- `options.topK`: 返回结果数量（默认 10）
- `options.threshold`: 相似度阈值（默认 0.1）

**返回：**
```typescript
interface SearchResult {
  id: string;              // 提示词 ID
  score: number;           // 相似度分数 (0-1)
  matchedKeywords: string[]; // 匹配的关键词
}
```

#### `indexBatch(prompts: Array<{id: string, text: string}>): Promise<void>`
批量索引提示词（用于初始化）。

#### `indexPrompt(id: string, text: string): Promise<void>`
索引单个提示词（增量更新）。

#### `removePrompt(id: string): Promise<void>`
删除提示词索引。

#### `getIndexedCount(): number`
获取已索引的提示词数量。

#### `getVocabularySize(): number`
获取词汇表大小。

## 性能优化建议

1. **延迟初始化**：在用户首次使用搜索功能时才初始化服务
2. **防抖搜索**：使用 debounce 避免频繁搜索
3. **缓存结果**：对相同查询缓存结果
4. **分批索引**：大量数据时分批索引，避免阻塞 UI

```typescript
// 使用 debounce 优化搜索
import { debounce } from 'lodash';

const debouncedSearch = debounce(async (query: string) => {
  await performSemanticSearch(query);
}, 300);
```

## 故障排除

### 问题：jieba-wasm 初始化失败
**解决方案**：确保 WASM 文件正确加载，检查网络和 CORS 配置。

### 问题：搜索结果不准确
**解决方案**：
1. 调整 `threshold` 阈值（降低以获取更多结果）
2. 增加 `topK` 数量
3. 检查停用词配置是否合理

### 问题：性能问题
**解决方案**：
1. 减少索引的提示词数量
2. 降低向量维度（修改 `VECTOR_DIM` 常量）
3. 使用 Web Worker 在后台线程执行搜索

## 测试

运行测试脚本验证功能：

```typescript
import { runSemanticSearchTest } from '@/service/testSemanticSearch';

// 在浏览器控制台中运行
runSemanticSearchTest();
```

## 未来优化方向

1. **Web Worker 集成**：将搜索移到后台线程
2. **增量词汇表更新**：避免每次都重建整个词汇表
3. **多语言支持**：针对不同语言使用不同的分词策略
4. **用户反馈学习**：根据用户点击行为调整相似度权重
